================================================================================
                    LAB 5: PROCESS MANAGEMENT - ANSWERS
                              Ahmed Kamel
================================================================================

================================================================================
EXERCISE 1: PROCESS CREATION USING fork()
================================================================================

The fork() System Call:
-----------------------
The fork() system call is used to create a new process in Unix/Linux systems.
When fork() is called, the operating system creates a copy of the calling
process (parent), resulting in a new process called the child process.

How fork() Works:
1. The parent process calls fork()
2. The OS creates an exact copy of the parent process
3. Both processes continue execution from the point after fork()
4. fork() returns different values to distinguish parent and child:
   - Returns 0 in the child process
   - Returns the child's PID (positive number) in the parent process
   - Returns -1 if fork() fails

Key Points:
- Parent and child have separate memory spaces (copy-on-write)
- Both processes run concurrently
- Child inherits file descriptors, environment, etc. from parent
- Each process has a unique Process ID (PID)

Code Example Explanation (process_creation.c):
The program demonstrates fork() by printing different messages based on
the return value of fork(). The parent prints its PID and the child's PID,
while the child prints its own PID and its parent's PID using getppid().

================================================================================
EXERCISE 5: THE LINKER
================================================================================

What is the Linker?
-------------------
The linker is a program that combines multiple object files (.o files) and
libraries into a single executable file. It is one of the final stages in
the compilation process.

The Linker's Job:
1. COMBINING OBJECT FILES:
   - Takes multiple .o files generated by the compiler
   - Merges them into a single executable
   - Example: file1.o + file2.o -> output_program

2. SYMBOL RESOLUTION:
   - Resolves references between different object files
   - Matches function calls to their definitions
   - Example: file2.c calls hello(), linker finds hello() in file1.c

3. RELOCATION:
   - Assigns final memory addresses to code and data
   - Updates all references to reflect these addresses

4. LIBRARY LINKING:
   - Links program code with library code (static or dynamic)
   - Static linking: copies library code into executable
   - Dynamic linking: creates references to shared libraries

Example Demonstration (file1.c and file2.c):
- file1.c defines the hello() function
- file2.c contains main() and calls hello()
- The linker combines both files, resolving the hello() symbol reference
- Command: gcc file1.c file2.c -o output_program

Without the linker, the compiler would produce separate object files that
cannot execute because references between files are unresolved.

================================================================================
EXERCISE 6: THE LOADER
================================================================================

What is the Loader?
-------------------
The loader is a part of the operating system that loads executable programs
into memory and prepares them for execution. It runs every time you execute
a program.

The Loader's Job:
1. LOADING INTO MEMORY:
   - Reads the executable file from disk
   - Allocates memory for the program
   - Copies program code and data into RAM

2. LOADING SHARED LIBRARIES:
   - Identifies required dynamic libraries (.so files on Linux)
   - Loads these libraries into memory
   - Common libraries: libc.so.6, libm.so.6, ld-linux.so

3. RUNTIME SYMBOL RESOLUTION:
   - Resolves references to functions in shared libraries
   - Updates memory addresses for dynamic library calls

4. PROGRAM PREPARATION:
   - Sets up the program's stack and heap
   - Initializes program registers
   - Transfers control to the program's entry point (main)

Viewing Shared Library Dependencies:
Use the 'ldd' command to see which shared libraries a program needs:
   $ ldd simple_program

Typical output shows:
- libc.so.6 -> C standard library (printf, malloc, etc.)
- libm.so.6 -> Math library (sqrt, sin, cos, etc.)
- ld-linux-x86-64.so.2 -> Dynamic linker/loader itself

Difference Between Linker and Loader:
- LINKER: Works at compile time, creates the executable
- LOADER: Works at runtime, loads and runs the executable

The linker creates the program structure, while the loader brings it to life
in memory when you execute the program.

================================================================================
                              END OF ANSWERS
================================================================================
